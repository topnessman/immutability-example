1. Think about adding readonly fields in a mutable class. In that case, we don't allow this class to be instantiated as immutable instance.
- Solved by adding addtional constraint on constructor parameters in immutable and polyimmutable constructor.
2. Does restricting all the constructor parameters to be @Immutable help preventing escape of @UnderInitialization @Mutable this to @Mutable aliases even in @Immutable constructors?
- I don't think we should make "this" mutable in immutable constructors. In nullness type system, fields type doesn't depend on receiver. If a fields is declared as @NonNull, then only assigning an object is enough. But in immutability type system, fields type depend on receiver, and the actual object captured by doesn't merely depend on field's declared type, for exmaple @PolyImmutable. In that sense, making "this" mutable in immutable constructor will violate such non-trivial context sensitivity(immutable object captured mutable objects) and results in invalid objects being captured. So we still need to use @Immutable in @Immutable constructor, and @PolyImmutable in @PolyImmutable constuctor. But I do agree the idea of using @UnderInitialization as the second type to indicate the initialization cases. For example, we can use @UnderInitialization @Immutable to be a type of object that indicates this object is immutable after initialization, but it's still effectively mutable now, because it's under initialization.
3. Think about removing the @Initialize annotation on method, and only need one common supertype annotation on "this" to allow initializing fields. Or How about @AssignFields annotation in Javari. Or in an immutable constructor, above which level in class hierarchy is immutable and below that boreder, "this" is still mutable.
I don't agree we need a common supertype annotation, because that will lose the context of "this" and fields cannot be treated differently according to context.
To simplify the system, I think only using @UnderInitialization for "this" but not tracking the level in type hierarchy is enough. If we use class literal as the values of @UnderInitialization, then fields in and above this class literal will never be reassigned by subclasses, which is too restrictive. Keeping "this" @Underinitialization until every constructor finishes doesn' post such constraint and allows fields to be reassigned in subclass contructors.
